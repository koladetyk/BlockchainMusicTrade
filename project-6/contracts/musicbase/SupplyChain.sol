pragma solidity ^0.4.24;

import "../musicaccesscontrol/ArtistRole.sol";
import "../musicaccesscontrol/RecordLabelRole.sol";
import "../musicaccesscontrol/DistributorRole.sol";
import "../musicaccesscontrol/ConsumerRole.sol";
import "../musiccore/Ownable.sol";

// Define a contract 'Supplychain'
contract SupplyChain is ArtistRole, RecordLabelRole, DistributorRole, ConsumerRole, Ownable{
    // Define 'owner'
    //address owner;

    // Define a variable called 'upc' for Universal Product Code (UPC)
    uint upc;

    // Define a variable called 'sku' for Stock Keeping Unit (SKU)
    uint sku;

    // Define a public mapping 'music' that maps the UPC to an Music.
    mapping (uint => Music) public music;

    // Define a public mapping 'musicHistory' that maps the UPC to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping (uint => string[]) public musicHistory;

    // Define enum 'State' with the following values:
    enum State {
        Made,       // 0
        Registered, // 1
        Verified,   // 2
        Promoted,   // 3
        Distributed,// 4
        ForSale,    // 5
        Bought,     // 6
        Listened    // 7
    }

    State constant defaultState = State.Made;

    // Define a struct to hold the music information
    struct MusicInfo {
        uint musicID;
        string musicNotes;
    }

    // Define a struct 'Music' with the following fields:
    struct Music {
        uint    sku;                // Stock Keeping Unit (SKU)
        uint    upc;                // Universal Product Code (UPC), generated by the Artist, goes on the package, can be verified by the Consumer
        address ownerID;            // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address artistID;     // Metamask-Ethereum address of the Artist
        uint    musicPrice;         // Music Price
        State   musicState;         // Music State as represented in the enum above
        address distributorID;      // Metamask-Ethereum address of the Distributor
        address recordLabelID;      // Metamask-Ethereum address of the RecordLabel
        address consumerID;         // Metamask-Ethereum address of the Consumer
        //MusicInfo musicInfo; 
        uint musicID;
        string musicNotes;
    }

    // Define 8 events with the same 8 state values and accept 'upc' as input argument
    event Made(uint upc);
    event Registered(uint upc);
    event Verified(uint upc);
    event Promoted(uint upc);
    event Distributed(uint upc);
    event ForSale(uint upc);
    event Bought(uint upc);
    event Listened(uint upc);

    // Define a modifier that checks to see if msg.sender == owner of the contract
    //odifier onlyOwner() {
    //    require(msg.sender == owner);
    //    _;
    //}

    // Define a modifier that verifies the Caller
    modifier verifyCaller(address _address) {
        require(msg.sender == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint _upc) {
        _;
        uint _price = music[_upc].musicPrice;
        uint amountToReturn = msg.value - _price;
        music[_upc].consumerID.transfer(amountToReturn);
    }

    // Define a modifier that checks if an music.state of a upc is Made
    modifier made(uint _upc) {
        require(music[_upc].musicState == State.Made);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is Registered
    modifier registered(uint _upc) {
        require(music[_upc].musicState == State.Registered);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is Verified
    modifier verified(uint _upc) {
        require(music[_upc].musicState == State.Verified);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is Promoted
    modifier promoted(uint _upc) {
        require(music[_upc].musicState == State.Promoted);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is Distributed
    modifier distributed(uint _upc) {
        require(music[_upc].musicState == State.Distributed);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is ForSale
    modifier forSale(uint _upc) {
        require(music[_upc].musicState == State.ForSale);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is Bought
    modifier bought(uint _upc) {
        require(music[_upc].musicState == State.Bought);
        _;
    }

    // Define a modifier that checks if an music.state of a upc is Listened
    modifier listened(uint _upc) {
        require(music[_upc].musicState == State.Listened);
        _;
    }

    // In the constructor set 'owner' to the address that instantiated the contract
    // and set 'sku' to 1
    // and set 'upc' to 1
    constructor() public payable {
        //owner = msg.sender;
        //sku = 1;
        //upc = 1;
    }

    // Define a function 'kill' if required
    function kill() public onlyOwner{
        selfdestruct(owner());
    }

    // Define a function 'makeMusic' that allows an artist to make music
    function makeMusic(uint psku, uint pupc, address pownerID, uint _musicID,string _musicNotes) public 
        onlyArtist
    {
      // Declare a variable of type MusicInfo
      //MusicInfo memory _musicInfo;

      //_musicInfo.musicID = 0;
      //_musicInfo.musicNotes = _musicNotes;

        // Add new music
        music[pupc] = Music({
            sku: psku,
            upc: pupc,
            ownerID: address(0x0),
            artistID: pownerID,
            musicPrice: 0,
            musicState: State.Made,
            distributorID: address(0x0),
            recordLabelID: address(0x0),
            consumerID: address(0x0),
            //musicInfo: _musicInfo // Assign the musicInfo struct to the musicInfo property
            musicID : _musicID,
            musicNotes : _musicNotes
        });
        // Increment sku
        music[pupc].sku = psku;
        //music[pupc].musicInfo.musicID = pupc*10 + sku;
        music[pupc].musicID = pupc+ psku;
        //console.log("here is my musicInfo = ", music[pupc].musicInfo.musicID)
        music[pupc].ownerID = owner();
        // Emit the appropriate event
        emit Made(pupc);
    }

    // Define a function 'registerMusic' that allows an artist to mark music as 'Registered'
    function registerMusic(uint _upc) public
        made(_upc)
        onlyArtist
        //verifyCaller(music[_upc].ArtistID)
    {
        // Update the appropriate fields
        music[_upc].musicState = State.Registered;

        // Emit the appropriate event
        emit Registered(_upc);
    }

    // Define a function 'verifyMusic' that allows a record Label to mark music as 'Verified'
    function verifyMusic(uint _upc) public
        registered(_upc)
        onlyRecordLabel
        //verifyCaller(music[_upc].originArtistID)
    {
        // Update the appropriate fields
        music[_upc].musicState = State.Verified;

        // Emit the appropriate event
        emit Verified(_upc);
    }

    // Define a function 'promoteMusic' that allows a record Label  to mark music as 'Promoted'
    function promoteMusic(uint _upc) public
        verified(_upc)
        onlyRecordLabel
        //verifyCaller(music[_upc].originArtistID)
    {
        // Update the appropriate fields
        music[_upc].musicState = State.Promoted;

        // Emit the appropriate event
        emit Promoted(_upc);
    }

    // Define a function 'distributeMusic' that allows a distributor to mark music as 'Distributed'
    function distributeMusic(uint _upc) public
        promoted(_upc)
        onlyDistributor
        //verifyCaller(music[_upc].originArtistID)
    {
        // Update the appropriate fields
        music[_upc].musicState = State.Distributed;

        // Emit the appropriate event
        emit Distributed(_upc);
    }

    // Define a function 'sellMusic' that allows a artist to mark music as 'ForSale'
    function sellMusic(uint _upc, uint _price) public
        distributed(_upc)
        onlyDistributor
        //verifyCaller(music[_upc].originArtistID)
    {
        // Update the appropriate fields
        music[_upc].musicState = State.ForSale;
        music[_upc].musicPrice = _price;

        // Emit the appropriate event
        emit ForSale(_upc);
    }

    // Define a function 'buyMusic' that allows the disributor to mark music as 'Bought'
    // Use the above defined modifiers to check if the music is available for sale, if the buyer has paid enough,
    // and any excess ether sent is refunded back to the buyer
    function buyMusic(uint _upc) public payable
        // Call modifier to check if upc has passed previous supply chain stage
        forSale(_upc)
        // Call modifier to check if buyer has paid enough
        paidEnough(music[_upc].musicPrice)
        //paidEnough(_upc)
        // Call modifier to send any excess ether back to buyer
        checkValue(_upc)
        onlyConsumer
    {
        // Store product owner before it's updated
        address origmMusicOwner = music[_upc].ownerID;

        // Update the appropriate fields - ownerID, distributorID, musicState
        music[_upc].ownerID = msg.sender;
        music[_upc].distributorID = msg.sender;
        music[_upc].musicState = State.Bought;

        // Transfer money to farmer
        origmMusicOwner.transfer(music[_upc].musicPrice);

        // Emit the appropriate event
        emit Bought(_upc);
    }

    // Define a function 'listenToMusic' that allow a consumer to 'listen to music'
    function listenToMusic(uint _upc) public
        bought(_upc)
        onlyConsumer
        //verifyCaller(music[_upc].originArtistID)
    {
        // Update the appropriate fields
        music[_upc].musicState = State.Listened;

        // Emit the appropriate event
        emit Listened(_upc);
    }

    function fetchmusicBufferOnePartOne(uint _upc) public view returns (
        uint    musicSKU,
        uint    musicUPC,
        address ownerID,
        address artistID
    ) {
        Music memory m = music[_upc];
        return (
            m.sku,
            m.upc,
            m.ownerID,
            m.artistID
        );
    }

    function fetchmusicBufferOnePartTwo(uint _upc) public view returns (
        uint    musicSKU,
        uint    musicUPC,
        uint    musicPrice, 
        uint   musicState,
        uint        musicID,
        string      musicNotes
    ) {
        Music memory m = music[_upc];
        return (
            m.sku,
            m.upc,
            m.musicPrice,
            uint(m.musicState),
            //m.musicInfo.musicID,
            m.musicID,
            m.musicNotes
            //m.musicInfo.musicNotes
        );
    }

    function fetchmusicBufferOnePartThree(uint _upc) public view returns (
        uint    musicSKU,
        uint    musicUPC,
        address artistID, 
        address distributorID,     
        address recordLabelID,     
        address consumerID 
    ) {
        Music memory m = music[_upc];
        return (
            m.sku,
            m.upc,
            m.artistID,
            m.distributorID,
            m.recordLabelID,
            m.consumerID
        );
    }
}